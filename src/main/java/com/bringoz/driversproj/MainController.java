package com.bringoz.driversproj;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.text.SimpleDateFormat;
import java.util.*;

@Controller	// This means that this class is a Controller
@RequestMapping(path="/drivers") // This means URL's start with /drivers (after Application path)
public class MainController {
	@Autowired // This means to get the bean called driverRepository
			   // Which is auto-generated by Spring, we will use it to handle the data
	private DriverRepository driverRepository;

	@PostMapping(path="/add") // Map ONLY POST Requests
	public @ResponseBody String addNewDriver (@RequestParam String name,
											  @RequestParam Integer age,
											  @RequestParam String address,
											  @RequestParam Status status,
											  @RequestParam Integer startWorkingHour,
											  @RequestParam Integer endWorkingHour,
											  @RequestParam Float latitude,
											  @RequestParam Float longitude)
	{
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		//TODO: Function to check variables validation. If not return "Variables validation failed".

		Driver driver = new Driver();
		driver.setName(name);
		driver.setAge(age);
		driver.setAddress(address);
		driver.setStatus(status);
		driver.setStartWorkingHour(startWorkingHour);
		driver.setEndWorkingHour(endWorkingHour);
		driver.setLatitude(latitude);
		driver.setLongitude(longitude);

		driverRepository.save(driver);
		return "Saved";
	}

	@GetMapping(path="/all")
	public @ResponseBody Iterable<Driver> getAllDrivers() {
		// This returns a JSON or XML with the drivers
		return driverRepository.findAll();
	}

	@DeleteMapping("/{id}")
	public Map<String, Boolean> deleteDriver(@PathVariable Integer id) {

		try {
			driverRepository.deleteById(id);
		}
		catch (Exception  e) {
			System.out.println(e.getMessage());
		}

		Map<String, Boolean> response = new HashMap<>();
		response.put("deleted", Boolean.TRUE);
		return response;
	}

	@GetMapping(path="/{id}")
	public @ResponseBody Optional<Driver> getDriver(@PathVariable Integer id) {
		// This returns the driver with the id equal to the parameter id
		return driverRepository.findById(id);
	}

	@PutMapping("/{id}")
	public @ResponseBody ResponseEntity<Driver> updateDriver(@RequestBody Driver driverDetails,
											   @PathVariable Integer id){
		// This returns the driver who was updated
		Optional<Driver> optionalDriver = driverRepository.findById(id);
		if (optionalDriver.isPresent()) {
			Driver driver = optionalDriver.get();
			driver.setName(driverDetails.getName());
			driver.setAge(driverDetails.getAge());
			driver.setAddress(driverDetails.getAddress());
			driver.setStatus(driverDetails.getStatus());
			driver.setStartWorkingHour(driverDetails.getStartWorkingHour());
			driver.setEndWorkingHour(driverDetails.getEndWorkingHour());
			driver.setLatitude(driverDetails.getLatitude());
			driver.setLongitude(driverDetails.getLongitude());

			final Driver updatedDriver = driverRepository.save(driver);
			return ResponseEntity.ok(updatedDriver);
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
	}

	@GetMapping(path="/active")
	public @ResponseBody ArrayList<Driver> getActiveDrivers() {
		// This returns the drivers with the "ACTIVE" status
		ArrayList<Driver> allDrivers = (ArrayList<Driver>) driverRepository.findAll();
		ArrayList<Driver> activeDrivers = new ArrayList<>();

		for (int i = 0; i < allDrivers.size(); i++) {
			if (allDrivers.get(i).getStatus() == Status.ACTIVE){
				activeDrivers.add(allDrivers.get(i));
			}
		}

		return activeDrivers;
	}

	@GetMapping(path="/mapBounds/{i}")
	public @ResponseBody Integer isDriverInMapBounds(@PathVariable Integer i){ //(@RequestParam Point point){

//		Polygon polygon = new Polygon();
//		polygon.addPoint(-10, -10);
//		polygon.addPoint(-10, 10);
//		polygon.addPoint(10, 10);
//		polygon.addPoint(10, -10);
//
//		System.out.println(polygon.contains(0, 0));
		return i;
	}


	@PostMapping(path="/timeWindow")
	public @ResponseBody ArrayList<Driver> getTimeWindowDrivers (@RequestParam Integer fromHour,
															  	 @RequestParam Integer toHour) {
		ArrayList<Driver> allDrivers = (ArrayList<Driver>) driverRepository.findAll();
		ArrayList<Driver> TimeWindowDrivers = new ArrayList<>();

		SimpleDateFormat formatter = new SimpleDateFormat("HH");

		try {
			Date from = formatter.parse(fromHour.toString());
			Date to = formatter.parse(toHour.toString());

			for (int i = 0; i < allDrivers.size(); i++) {
				Date startWorkingHour = formatter.parse(allDrivers.get(i).getStartWorkingHour().toString());
				Date endWorkingHour = formatter.parse(allDrivers.get(i).getEndWorkingHour().toString());
				if (from.compareTo(startWorkingHour) <= 0 &&  to.compareTo(endWorkingHour) >= 0){
					TimeWindowDrivers.add(allDrivers.get(i));
				}
			}
		}
		catch (java.text.ParseException e) {};

		return TimeWindowDrivers;
	}

}
